{
  "695ac30889c1fafbc2ac14ebf8017480": {
    "topic": "loops",
    "type": "true_false",
    "difficulty": "hard",
    "user_id": "guest",
    "quiz": "Okay, here are 10 True/False questions related to C loops, based on the provided passage, designed to be challenging:\n\nQ1. In C, it's always possible to convert a 'while' loop into a 'for' loop and vice versa without changing the program's functionality.\nAnswer: True\n\nQ2. Within a `do-while` loop, the conditional test is performed before the first execution of the loop body.\nAnswer: False\n\nQ3. The `break` statement, when encountered inside a nested loop, terminates all levels of loops immediately.\nAnswer: False\n\nQ4. Incrementing a loop counter in a `for` loop is restricted to increments of 1.\nAnswer: False\n\nQ5. An arithmetic expression such as `if (3 + 2 % 5)` is invalid for constructing decision control instruction.\nAnswer: False\n\nQ6. When using nested loops, the inner loop must always complete all its iterations before the outer loop increments and continues.\nAnswer: False\n\nQ7. A non-zero value is considered true in a C conditional statement.\nAnswer: True\n\nQ8. The 'continue' statement inside a loop always forces the program to exit the loop entirely.\nAnswer: False\n\nQ9. It is impossible to have a loop that executes zero times if the initial condition is false.\nAnswer: False\n\nQ10. There is a direct and efficient way to perform an exponentiation operation using only the while loop.\nAnswer: False\n"
  },
  "b70ddd9af7f15bab50eaf21ced3003b9": {
    "topic": "linked list",
    "type": "true_false",
    "difficulty": "hard",
    "user_id": "guest",
    "quiz": "Here are 10 True/False questions based on the provided text, designed to be difficult and require close reading:\n\nQ1. A programmer can determine which of two linked list implementations is more space efficient simply by comparing the sizes of the variables used in the class definition.\nAnswer: False (Consideration of how many elements will actually be stored is also necessary.)\n\nQ2. The concept of an Abstract Data Type (ADT) for data types is only relevant to programming applications and has no application in other fields.\nAnswer: False (Example 1.6 demonstrates its use in non-computing contexts.)\n\nQ3. Given the information available in this book, it would be possible to devise a sorting algorithm that has a lower bound of O(n) for the cost of execution.\nAnswer: False (Later chapters prove a lower bound of O(n log n) for comparison-based sorting.)\n\nQ4. If two algorithms for the same problem have been implemented with equal skill and are run on identical computers, their relative performance will exactly match the asymptotic analysis provided in this text.\nAnswer: False (Constants and lower-order terms can affect performance, especially for small input sizes.)\n\nQ5. The goal of the Strategy design pattern is to encapsulate an activity that will be performed on all members of a collection.\nAnswer: False (The Strategy design pattern is focused on encapsulating an activity that is part of a larger process. It is the Visitor design pattern that encapsulates an activity to be performed on all members of a collection.)\n\nQ6. An algorithm can only be technically called an algorithm if it has been written as a compilable computer program.\nAnswer: False (An algorithm can be described in pseudocode or English.)\n\nQ7. Flyweight design pattern is used when an application has to process several different actions based on an object sub class.\nAnswer: False (This describes the Composite design pattern.)\n\nQ8. Any Java environment will always provide a list class that has the same functionality (functions, inputs, and outputs) as the List ADT in this text.\nAnswer: False (The logical form of a list is only defined by its public functions. The functions can have different names or behaviours in other environments)\n\nQ9. The author argues that terminating a program when a function receives a bad parameter is generally considered undesirable in real programs.\nAnswer: True (He states that assertions provide a simpler mechanism, while Java's exception handling should be used in real programs.)\n\nQ10. While the `int` variable type is a physical representation of an abstract integer, it is perfectly true to the abstract integer because there are no limitations on the range of values an `int` variable can store.\nAnswer: False (There *are* limitations on the range of values an `int` variable can store.)\n"
  },
  "74ecd38b6538981e9640cb941c24f37a": {
    "topic": "stacks",
    "type": "true_false",
    "difficulty": "hard",
    "user_id": "guest",
    "quiz": "Here are 10 hard True/False questions about stacks, based solely on the provided passage.\n\nQ1. Dynamic storage allocation is a crucial advantage when using array-based stacks, allowing them to resize automatically as needed.\nAnswer: False\n\nQ2. For a queue, the implementation in the passage will ensure elements are released in reverse of the order in which they arrived.\nAnswer: False\n\nQ3. In an object-oriented language like Java, data types always have both a logical and a physical form as defined by an abstract data type (ADT) and the data structure where it is implemented.\nAnswer: True\n\nQ4. For a stack, the amount of space needed can be determined accurately only during the execution of a program.\nAnswer: False\n\nQ5. Stacks do not support list operation where all basic operations such as inserting a data item into the data structure, deleting a data item from the data structure, and finding a specified data item must be supported.\nAnswer: True\n\nQ6. The passage identifies \"LIFO\" as a term exclusively related to bank transactions.\nAnswer: False\n\nQ7. According to the passage, the primary reason to study stacks is to improve an accountant's organization of paper bills.\nAnswer: False\n\nQ8. One advantage of an Abstract Data Type (ADT) is that implementation details are not specified.\nAnswer: True\n\nQ9. Linked list or array-based implementations of the ADT are referred to as design patterns.\nAnswer: False\n\nQ10. A good design of program does not con\ufb02ict with ef\ufb01cient performance.\nAnswer: True\n"
  },
  "0f9b959d45dc64c3d783655ee67113b8": {
    "topic": "stack",
    "type": "true_false",
    "difficulty": "hard",
    "user_id": "guest",
    "quiz": "Okay, here are 10 hard True/False questions based on the provided text concerning the \"stack\" data structure:\n\nQ1. An \"activation record\" is the name for the memory space allocated and deallocated in a stack-like fashion by a memory manager.\nAnswer: False\n\nQ2. A stack is least effecient for insert and remove operations compared to other data structures.\nAnswer: True\n\nQ3. In Java, it is mandatory to have a user-defined data structure that extends the list interface to implement a \"stack\" data structure.\nAnswer: False\n\nQ4. Unlike standard list data structures, the size of \"Stack\" data structure can not be increased or decreased.\nAnswer: False\n\nQ5. Stacks can be particularly effective because double buffering provides more efficient and better organized data for efficient processing.\nAnswer: False\n\nQ6. \"topValue()\" method does not exist in Stack ADT.\nAnswer: False\n\nQ7. A stack implementation has a constant time push or pop operation, whether that implementation is array-based or linked-based.\nAnswer: True\n\nQ8. A trace of fact's execution in which a stack stores both the return address and value of \"n\", is an example of the Flyweight design pattern.\nAnswer: False\n\nQ9. The visitor design pattern can avoid rewriting the traversal function by encapsulating the activity performed at each node and is useful in stacks.\nAnswer: False\n\nQ10. A recursive algorithm can be converted to iterative algorithm by manually implementing its call stack.\nAnswer: True\n"
  },
  "4731978ad396d2cf84457da3c38ba887": {
    "topic": "queue",
    "type": "true_false",
    "difficulty": "hard",
    "user_id": "guest",
    "quiz": "Here are 5 hard level True or False questions based on the text provided, focusing on key details, implementation nuances, and potential misinterpretations:\n\nQ1. In an array-based queue implementation, it's possible for the \"enqueue\" and \"dequeue\" operations to have a worst-case time complexity of O(1) regardless of the number of elements in the queue.\nAnswer: True\n\nQ2. A double buffering strategy to optimize I/O in file processing would involve using two buffer pools, one managed according to the LRU principle and another to write modified information to disk.\nAnswer: False\n\nQ3. According to the passage, if a disk drive has sectors organized into zones with consistent data density, then an application performing sequential processing would experience uniform transfer speeds across all regions of the disk.\nAnswer: True\n\nQ4. If the value for any given parameter,  \ud835\udc47(\ud835\udc5b) must always be non-negative. \nAnswer: True\n\nQ5. Self-organizing lists are most appropriate when the expected access probability for each record is known in advance and remains constant over time.\nAnswer: False\n"
  }
}